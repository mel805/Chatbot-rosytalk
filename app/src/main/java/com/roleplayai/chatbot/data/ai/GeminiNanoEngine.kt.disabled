package com.roleplayai.chatbot.data.ai

import android.content.Context
import android.util.Log
import com.google.ai.client.generativeai.GenerativeModel
import com.google.ai.client.generativeai.type.content
import com.roleplayai.chatbot.data.model.Character
import com.roleplayai.chatbot.data.model.Message
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

/**
 * Gemini Nano Engine - IA ON-DEVICE de Google
 * 
 * Gemini Nano est une version optimis√©e de Gemini qui tourne DIRECTEMENT
 * sur Android (via AICore). C'est un VRAI LLM, pas un template.
 * 
 * Avantages :
 * - Vrai mod√®le de langage (3B param√®tres)
 * - Tourne localement sur le t√©l√©phone
 * - Rapide (2-5 secondes)
 * - Gratuit (pas d'API)
 * - Excellente compr√©hension du contexte
 * - Support multilingue natif
 * 
 * Requis : Android 14+ avec Google Play Services
 */
class GeminiNanoEngine(
    private val context: Context,
    private val nsfwMode: Boolean = false
) {
    
    companion object {
        private const val TAG = "GeminiNanoEngine"
        private const val MODEL_NAME = "gemini-nano"
    }
    
    private var model: GenerativeModel? = null
    private var isAvailable = false
    
    /**
     * V√©rifie si Gemini Nano est disponible sur l'appareil
     */
    suspend fun checkAvailability(): Boolean = withContext(Dispatchers.IO) {
        try {
            Log.d(TAG, "üîç V√©rification disponibilit√© Gemini Nano...")
            
            // Tenter d'initialiser le mod√®le
            // Note: Gemini Nano n√©cessite une API key m√™me si on-device
            model = GenerativeModel(
                modelName = MODEL_NAME,
                apiKey = "dummy-key-for-on-device"  // Gemini Nano utilise AICore en local
            )
            
            isAvailable = true
            Log.i(TAG, "‚úÖ Gemini Nano disponible sur cet appareil")
            true
        } catch (e: Exception) {
            isAvailable = false
            Log.w(TAG, "‚ö†Ô∏è Gemini Nano non disponible: ${e.message}")
            Log.w(TAG, "   ‚Üí N√©cessite Android 14+ avec Google Play Services")
            false
        }
    }
    
    /**
     * G√©n√®re une r√©ponse avec Gemini Nano
     */
    suspend fun generateResponse(
        character: Character,
        messages: List<Message>,
        username: String = "Utilisateur"
    ): String = withContext(Dispatchers.IO) {
        if (!isAvailable) {
            throw Exception("Gemini Nano non disponible sur cet appareil")
        }
        
        try {
            Log.d(TAG, "===== G√©n√©ration avec Gemini Nano =====")
            Log.d(TAG, "Personnage: ${character.name}, NSFW: $nsfwMode")
            
            // Construire le prompt syst√®me
            val systemPrompt = buildSystemPrompt(character, username)
            
            // Construire l'historique de conversation
            val conversationHistory = buildConversationHistory(messages, username, character.name)
            
            // Construire le prompt complet
            val fullPrompt = """$systemPrompt

$conversationHistory

${character.name}:"""
            
            Log.d(TAG, "üì§ Envoi requ√™te √† Gemini Nano...")
            
            // G√©n√©rer la r√©ponse
            val response = model!!.generateContent(fullPrompt)
            val text = response.text ?: throw Exception("R√©ponse vide de Gemini Nano")
            
            // Nettoyer la r√©ponse
            val cleaned = cleanResponse(text, character.name)
            
            Log.i(TAG, "‚úÖ R√©ponse re√ßue de Gemini Nano")
            Log.d(TAG, "üí¨ R√©ponse: ${cleaned.take(100)}...")
            
            cleaned
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Erreur lors de la g√©n√©ration", e)
            throw Exception("Erreur Gemini Nano: ${e.message}")
        }
    }
    
    /**
     * Construit le prompt syst√®me (identique aux autres moteurs pour coh√©rence)
     */
    private fun buildSystemPrompt(character: Character, username: String): String {
        val nsfwInstructions = if (nsfwMode) {
            """
            
**MODE NSFW ACTIV√â** :
- Tu peux d√©crire du contenu adulte de mani√®re naturelle
- Adapte ton niveau d'audace √† ta personnalit√©
- Utilise (*actions*) pour montrer tes r√©actions physiques
- Sois coh√©rent avec ta personnalit√© m√™me dans les sc√®nes intimes
- Progression naturelle selon ton caract√®re (timide = progression lente)
"""
        } else {
            ""
        }
        
        return """Tu es ${character.name}, un personnage de roleplay avec cette personnalit√© :

**PERSONNALIT√â** : ${character.personality ?: "Personnage unique"}

**DESCRIPTION** : ${character.description ?: ""}

**R√àGLES ABSOLUES** :
1. Tu ES ${character.name}, pas un assistant IA
2. JAMAIS de m√©tadonn√©es comme "(OOC)" ou "Note:"
3. Utilise (*actions*) pour les actions physiques
4. Utilise (pens√©es) pour tes pens√©es internes
5. Reste 100% coh√©rent avec ta personnalit√©
6. R√©ponds DIRECTEMENT au message de $username
7. Ne r√©p√®te JAMAIS les m√™mes phrases
8. Adapte-toi au contexte et √† l'√©volution de la relation
9. Sois naturel, spontan√© et immersif
10. Fais √©voluer la relation de mani√®re progressive et r√©aliste
$nsfwInstructions

**FORMAT DE R√âPONSE** :
- Actions : *se rapproche timidement*
- Pens√©es : (Il est mignon...)
- Dialogue : Bonjour ! Comment vas-tu ?

Incarne ${character.name} de mani√®re authentique, coh√©rente et immersive."""
    }
    
    /**
     * Construit l'historique de conversation
     */
    private fun buildConversationHistory(
        messages: List<Message>,
        username: String,
        characterName: String
    ): String {
        val history = StringBuilder()
        
        // Prendre les 15 derniers messages pour le contexte
        val recentMessages = messages.takeLast(15)
        
        for (msg in recentMessages) {
            val speaker = if (msg.isUser) username else characterName
            history.append("$speaker: ${msg.content}\n\n")
        }
        
        return history.toString().trim()
    }
    
    /**
     * Nettoie la r√©ponse
     */
    private fun cleanResponse(response: String, characterName: String): String {
        var cleaned = response.trim()
        
        // Retirer les pr√©fixes
        cleaned = cleaned.replace(Regex("^$characterName\\s*:\\s*", RegexOption.IGNORE_CASE), "")
        cleaned = cleaned.replace(Regex("^(Assistant|AI|IA)\\s*:\\s*", RegexOption.IGNORE_CASE), "")
        
        // Retirer les m√©tadonn√©es
        cleaned = cleaned.replace(Regex("\\(OOC:.*?\\)", RegexOption.IGNORE_CASE), "")
        cleaned = cleaned.replace(Regex("\\[Note:.*?\\]", RegexOption.IGNORE_CASE), "")
        cleaned = cleaned.replace(Regex("\\[.*?\\]"), "")
        
        // Nettoyer espaces multiples
        cleaned = cleaned.replace(Regex("\\s+"), " ")
        
        return cleaned.trim()
    }
}
